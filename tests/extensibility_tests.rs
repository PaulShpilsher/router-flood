//! Extensibility tests moved from inline tests\n//!\n//! This module contains tests to verify extensibility patterns work\n//! without causing circular dependencies or compilation timeouts.\n\nuse router_flood::error::Result;\nuse std::sync::Arc;\nuse std::net::IpAddr;\n\n// === Basic Pattern Tests ===\n\n#[test]\nfn test_basic_extensibility() {\n    // Test that basic extensibility patterns compile and work\n    assert!(true);\n}\n\n#[test]\nfn test_trait_objects() {\n    // Test that trait objects work for extensibility\n    trait TestTrait {\n        fn test_method(&self) -> u32;\n    }\n    \n    struct TestImpl;\n    impl TestTrait for TestImpl {\n        fn test_method(&self) -> u32 {\n            42\n        }\n    }\n    \n    let test_obj: Box<dyn TestTrait> = Box::new(TestImpl);\n    assert_eq!(test_obj.test_method(), 42);\n}\n\n#[test]\nfn test_arc_trait_objects() {\n    // Test that Arc<dyn Trait> works for shared extensibility\n    trait SharedTrait: Send + Sync {\n        fn shared_method(&self) -> String;\n    }\n    \n    struct SharedImpl {\n        value: String,\n    }\n    \n    impl SharedTrait for SharedImpl {\n        fn shared_method(&self) -> String {\n            self.value.clone()\n        }\n    }\n    \n    let shared_obj: Arc<dyn SharedTrait> = Arc::new(SharedImpl {\n        value: \"test\".to_string(),\n    });\n    \n    assert_eq!(shared_obj.shared_method(), \"test\");\n}\n\n#[test]\nfn test_generic_extensibility() {\n    // Test generic-based extensibility patterns\n    trait GenericTrait<T> {\n        fn process(&self, input: T) -> T;\n    }\n    \n    struct GenericImpl;\n    \n    impl GenericTrait<u32> for GenericImpl {\n        fn process(&self, input: u32) -> u32 {\n            input * 2\n        }\n    }\n    \n    impl GenericTrait<String> for GenericImpl {\n        fn process(&self, input: String) -> String {\n            format!(\"processed: {}\", input)\n        }\n    }\n    \n    let processor = GenericImpl;\n    assert_eq!(processor.process(21u32), 42);\n    assert_eq!(processor.process(\"test\".to_string()), \"processed: test\");\n}\n\n#[test]\nfn test_builder_pattern() {\n    // Test builder pattern for extensibility\n    struct TestConfig {\n        value1: u32,\n        value2: String,\n        value3: bool,\n    }\n    \n    struct TestConfigBuilder {\n        value1: Option<u32>,\n        value2: Option<String>,\n        value3: Option<bool>,\n    }\n    \n    impl TestConfigBuilder {\n        fn new() -> Self {\n            Self {\n                value1: None,\n                value2: None,\n                value3: None,\n            }\n        }\n        \n        fn with_value1(mut self, value: u32) -> Self {\n            self.value1 = Some(value);\n            self\n        }\n        \n        fn with_value2(mut self, value: String) -> Self {\n            self.value2 = Some(value);\n            self\n        }\n        \n        fn with_value3(mut self, value: bool) -> Self {\n            self.value3 = Some(value);\n            self\n        }\n        \n        fn build(self) -> TestConfig {\n            TestConfig {\n                value1: self.value1.unwrap_or(0),\n                value2: self.value2.unwrap_or_else(|| \"default\".to_string()),\n                value3: self.value3.unwrap_or(false),\n            }\n        }\n    }\n    \n    let config = TestConfigBuilder::new()\n        .with_value1(42)\n        .with_value2(\"test\".to_string())\n        .with_value3(true)\n        .build();\n    \n    assert_eq!(config.value1, 42);\n    assert_eq!(config.value2, \"test\");\n    assert_eq!(config.value3, true);\n}\n\n#[test]\nfn test_strategy_pattern() {\n    // Test strategy pattern for extensibility\n    trait Strategy {\n        fn execute(&self, input: u32) -> u32;\n    }\n    \n    struct AddStrategy(u32);\n    struct MultiplyStrategy(u32);\n    \n    impl Strategy for AddStrategy {\n        fn execute(&self, input: u32) -> u32 {\n            input + self.0\n        }\n    }\n    \n    impl Strategy for MultiplyStrategy {\n        fn execute(&self, input: u32) -> u32 {\n            input * self.0\n        }\n    }\n    \n    struct Context {\n        strategy: Box<dyn Strategy>,\n    }\n    \n    impl Context {\n        fn new(strategy: Box<dyn Strategy>) -> Self {\n            Self { strategy }\n        }\n        \n        fn execute(&self, input: u32) -> u32 {\n            self.strategy.execute(input)\n        }\n    }\n    \n    let add_context = Context::new(Box::new(AddStrategy(10)));\n    assert_eq!(add_context.execute(5), 15);\n    \n    let multiply_context = Context::new(Box::new(MultiplyStrategy(3)));\n    assert_eq!(multiply_context.execute(5), 15);\n}\n\n#[test]\nfn test_observer_pattern() {\n    // Test observer pattern for extensibility\n    use std::sync::Mutex;\n    \n    trait Observer {\n        fn notify(&self, event: &str);\n    }\n    \n    struct TestObserver {\n        events: Mutex<Vec<String>>,\n    }\n    \n    impl TestObserver {\n        fn new() -> Self {\n            Self {\n                events: Mutex::new(Vec::new()),\n            }\n        }\n        \n        fn get_events(&self) -> Vec<String> {\n            self.events.lock().unwrap().clone()\n        }\n    }\n    \n    impl Observer for TestObserver {\n        fn notify(&self, event: &str) {\n            self.events.lock().unwrap().push(event.to_string());\n        }\n    }\n    \n    struct Subject {\n        observers: Vec<Arc<dyn Observer + Send + Sync>>,\n    }\n    \n    impl Subject {\n        fn new() -> Self {\n            Self {\n                observers: Vec::new(),\n            }\n        }\n        \n        fn attach(&mut self, observer: Arc<dyn Observer + Send + Sync>) {\n            self.observers.push(observer);\n        }\n        \n        fn notify_all(&self, event: &str) {\n            for observer in &self.observers {\n                observer.notify(event);\n            }\n        }\n    }\n    \n    let observer1 = Arc::new(TestObserver::new());\n    let observer2 = Arc::new(TestObserver::new());\n    \n    let mut subject = Subject::new();\n    subject.attach(observer1.clone());\n    subject.attach(observer2.clone());\n    \n    subject.notify_all(\"test_event\");\n    \n    assert_eq!(observer1.get_events(), vec![\"test_event\"]);\n    assert_eq!(observer2.get_events(), vec![\"test_event\"]);\n}\n\n#[test]\nfn test_plugin_registry_pattern() {\n    // Test plugin registry pattern for extensibility\n    use std::collections::HashMap;\n    \n    trait Plugin {\n        fn name(&self) -> &str;\n        fn execute(&self, input: &str) -> String;\n    }\n    \n    struct UppercasePlugin;\n    struct ReversePlugin;\n    \n    impl Plugin for UppercasePlugin {\n        fn name(&self) -> &str {\n            \"uppercase\"\n        }\n        \n        fn execute(&self, input: &str) -> String {\n            input.to_uppercase()\n        }\n    }\n    \n    impl Plugin for ReversePlugin {\n        fn name(&self) -> &str {\n            \"reverse\"\n        }\n        \n        fn execute(&self, input: &str) -> String {\n            input.chars().rev().collect()\n        }\n    }\n    \n    struct PluginRegistry {\n        plugins: HashMap<String, Box<dyn Plugin>>,\n    }\n    \n    impl PluginRegistry {\n        fn new() -> Self {\n            Self {\n                plugins: HashMap::new(),\n            }\n        }\n        \n        fn register(&mut self, plugin: Box<dyn Plugin>) {\n            let name = plugin.name().to_string();\n            self.plugins.insert(name, plugin);\n        }\n        \n        fn execute(&self, plugin_name: &str, input: &str) -> Option<String> {\n            self.plugins.get(plugin_name).map(|plugin| plugin.execute(input))\n        }\n    }\n    \n    let mut registry = PluginRegistry::new();\n    registry.register(Box::new(UppercasePlugin));\n    registry.register(Box::new(ReversePlugin));\n    \n    assert_eq!(registry.execute(\"uppercase\", \"hello\"), Some(\"HELLO\".to_string()));\n    assert_eq!(registry.execute(\"reverse\", \"hello\"), Some(\"olleh\".to_string()));\n    assert_eq!(registry.execute(\"nonexistent\", \"hello\"), None);\n}\n"