//! Phase 5 integration tests\n//!\n//! Tests for advanced features including real-time dashboard\n//! and security hardening capabilities.\n\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::time;\n\nuse router_flood::phase5::{\n    Phase5Runner, Phase5Config, init_phase5, create_minimal_config, create_high_security_config\n};\nuse router_flood::monitoring::{\n    DashboardBuilder, AlertThresholds\n};\nuse router_flood::security::{\n    ThreatDetectionConfig, ValidationConfig, SecurityInputValidator,\n    create_strict_validator, validate_ip_strict, validate_ports_strict\n};\n\n#[tokio::test]\nasync fn test_phase5_initialization() {\n    let runner = init_phase5().expect(\"Failed to initialize Phase 5\");\n    \n    // Test that all components are properly initialized\n    let security_context = runner.get_security_context();\n    assert_eq!(security_context.threats_detected, 0);\n    \n    let monitoring_summary = runner.get_monitoring_summary();\n    assert!(monitoring_summary.performance_score >= 0.0);\n}\n\n#[tokio::test]\nasync fn test_minimal_config() {\n    let config = create_minimal_config();\n    let runner = Phase5Runner::new(config).expect(\"Failed to create Phase 5 runner\");\n    \n    // Test minimal configuration\n    let security_context = runner.get_security_context();\n    assert_eq!(security_context.threats_detected, 0);\n}\n\n#[tokio::test]\nasync fn test_high_security_config() {\n    let config = create_high_security_config();\n    let runner = Phase5Runner::new(config).expect(\"Failed to create Phase 5 runner\");\n    \n    // Test high security configuration\n    let security_context = runner.get_security_context();\n    assert_eq!(security_context.threats_detected, 0);\n}\n\n#[tokio::test]\nasync fn test_configuration_validation() {\n    let runner = init_phase5().expect(\"Failed to initialize Phase 5\");\n    \n    // Test valid configuration\n    let valid_config = r#\"\n        target:\n          ip: \"192.168.1.1\"\n          ports: [80, 443]\n        test:\n          intensity: medium\n          duration: 30\n    \"#;\n    \n    assert!(runner.validate_configuration(valid_config).is_ok());\n    \n    // Test configuration with suspicious patterns\n    let suspicious_config = r#\"\n        target:\n          ip: \"192.168.1.1\"\n          ports: [80, 443]\n        test:\n          intensity: medium\n          duration: 30\n        # <script>alert('xss')</script>\n    \"#;\n    \n    // Should still pass but with warnings\n    assert!(runner.validate_configuration(suspicious_config).is_ok());\n}\n\n#[tokio::test]\nasync fn test_ip_validation() {\n    let runner = init_phase5().expect(\"Failed to initialize Phase 5\");\n    \n    // Test valid private IP\n    assert!(runner.validate_target_ip(\"192.168.1.1\").is_ok());\n    assert!(runner.validate_target_ip(\"10.0.0.1\").is_ok());\n    assert!(runner.validate_target_ip(\"172.16.0.1\").is_ok());\n    \n    // Test invalid public IP\n    assert!(runner.validate_target_ip(\"8.8.8.8\").is_err());\n    assert!(runner.validate_target_ip(\"1.1.1.1\").is_err());\n    \n    // Test invalid format\n    assert!(runner.validate_target_ip(\"invalid.ip\").is_err());\n}\n\n#[tokio::test]\nasync fn test_port_validation() {\n    let runner = init_phase5().expect(\"Failed to initialize Phase 5\");\n    \n    // Test valid port list\n    let valid_ports = vec![80, 443, 8080];\n    assert!(runner.validate_ports(&valid_ports).is_ok());\n    \n    // Test empty port list\n    let empty_ports = vec![];\n    assert!(runner.validate_ports(&empty_ports).is_err());\n    \n    // Test excessive port list (should fail with high security)\n    let excessive_ports: Vec<u16> = (1..=200).collect();\n    let high_security_runner = Phase5Runner::new(create_high_security_config())\n        .expect(\"Failed to create high security runner\");\n    assert!(high_security_runner.validate_ports(&excessive_ports).is_err());\n}\n\n#[tokio::test]\nasync fn test_security_input_validator() {\n    let validator = create_strict_validator();\n    \n    // Test string validation\n    let result = validator.validate_string(\"normal_string\", \"test_field\");\n    assert!(result.is_ok());\n    let validated = result.unwrap();\n    assert!(!validated.value.was_modified());\n    assert!(validated.warnings.is_empty());\n    \n    // Test string with suspicious content\n    let result = validator.validate_string(\"<script>alert('xss')</script>\", \"test_field\");\n    assert!(result.is_ok());\n    let validated = result.unwrap();\n    assert!(!validated.security_notes.is_empty());\n    \n    // Test filename validation\n    let result = validator.validate_filename(\"valid_file.txt\");\n    assert!(result.is_ok());\n    \n    let result = validator.validate_filename(\"../../../etc/passwd\");\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_ip_validation_strict() {\n    // Test strict IP validation\n    let result = validate_ip_strict(\"192.168.1.1\");\n    assert!(result.is_ok());\n    let validated_ip = result.unwrap();\n    assert!(validated_ip.is_private);\n    \n    let result = validate_ip_strict(\"8.8.8.8\");\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_port_validation_strict() {\n    // Test strict port validation\n    let valid_ports = vec![80, 443];\n    let result = validate_ports_strict(&valid_ports);\n    assert!(result.is_ok());\n    \n    // Test excessive ports\n    let excessive_ports: Vec<u16> = (1..=200).collect();\n    let result = validate_ports_strict(&excessive_ports);\n    assert!(result.is_err());\n}\n\n#[tokio::test]\nasync fn test_metrics_integration() {\n    let runner = init_phase5().expect(\"Failed to initialize Phase 5\");\n    let collector = runner.metrics_collector();\n    \n    // Record some test metrics\n    collector.record_packet_sent(64);\n    collector.record_packet_sent(128);\n    collector.record_packet_failed();\n    \n    let metrics = collector.get_metrics();\n    assert_eq!(metrics.packets_sent, 2);\n    assert_eq!(metrics.packets_failed, 1);\n    assert_eq!(metrics.bytes_sent, 192);\n    \n    // Test monitoring summary\n    let summary = runner.get_monitoring_summary();\n    assert!(summary.performance_score > 0.0);\n}\n\n#[tokio::test]\nasync fn test_dashboard_config_builder() {\n    let config = DashboardBuilder::new()\n        .update_interval(Duration::from_millis(500))\n        .compact_mode(true)\n        .show_progress_bar(false)\n        .alert_thresholds(AlertThresholds {\n            max_failure_rate: 5.0,\n            min_success_rate: 95.0,\n            max_response_time: 100.0,\n            min_throughput: 10.0,\n        })\n        .build();\n    \n    assert_eq!(config.update_interval, Duration::from_millis(500));\n    assert!(config.compact_mode);\n    assert!(!config.show_progress_bar);\n    assert_eq!(config.alert_thresholds.max_failure_rate, 5.0);\n}\n\n#[tokio::test]\nasync fn test_threat_detection_config() {\n    let config = ThreatDetectionConfig {\n        enable_rate_limiting: true,\n        enable_input_validation: true,\n        enable_anomaly_detection: false,\n        max_requests_per_minute: 100,\n        max_packet_size: 1500,\n        max_target_ports: 50,\n        suspicious_pattern_threshold: 10,\n    };\n    \n    assert!(config.enable_rate_limiting);\n    assert!(config.enable_input_validation);\n    assert!(!config.enable_anomaly_detection);\n    assert_eq!(config.max_requests_per_minute, 100);\n}\n\n#[tokio::test]\nasync fn test_validation_config() {\n    let config = ValidationConfig {\n        max_string_length: 512,\n        max_array_size: 50,\n        allow_special_chars: false,\n        strict_ip_validation: true,\n        enable_pattern_detection: true,\n    };\n    \n    let validator = SecurityInputValidator::new(config);\n    \n    // Test with the configured limits\n    let long_string = \"a\".repeat(600);\n    let result = validator.validate_string(&long_string, \"test\");\n    assert!(result.is_err()); // Should exceed max_string_length\n}\n\n#[tokio::test]\nasync fn test_export_report() {\n    let runner = init_phase5().expect(\"Failed to initialize Phase 5\");\n    \n    // Record some test data\n    let collector = runner.metrics_collector();\n    collector.record_packet_sent(64);\n    collector.record_packet_sent(128);\n    \n    // Export report\n    let filename = \"test_phase5_report.json\";\n    let result = runner.export_report(filename).await;\n    assert!(result.is_ok());\n    \n    // Verify file exists\n    assert!(tokio::fs::metadata(filename).await.is_ok());\n    \n    // Clean up\n    let _ = tokio::fs::remove_file(filename).await;\n}\n\n#[tokio::test]\nasync fn test_security_context() {\n    let runner = init_phase5().expect(\"Failed to initialize Phase 5\");\n    \n    let security_context = runner.get_security_context();\n    assert_eq!(security_context.threats_detected, 0);\n    assert_eq!(security_context.validation_failures, 0);\n    \n    // Security level should be safe initially\n    use router_flood::phase5::SecurityLevel;\n    assert_eq!(security_context.security_level, SecurityLevel::Safe);\n}\n\n#[tokio::test]\nasync fn test_phase5_start_stop() {\n    let runner = init_phase5().expect(\"Failed to initialize Phase 5\");\n    let running = Arc::new(AtomicBool::new(true));\n    \n    // Start Phase 5 in background\n    let runner_clone = runner;\n    let running_clone = Arc::clone(&running);\n    \n    let handle = tokio::spawn(async move {\n        runner_clone.start(running_clone).await\n    });\n    \n    // Let it run briefly\n    time::sleep(Duration::from_millis(100)).await;\n    \n    // Stop it\n    running.store(false, Ordering::Relaxed);\n    \n    // Wait for completion\n    let result = tokio::time::timeout(Duration::from_secs(5), handle).await;\n    assert!(result.is_ok());\n    assert!(result.unwrap().is_ok());\n}\n"