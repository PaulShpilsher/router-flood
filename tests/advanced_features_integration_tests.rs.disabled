//! Advanced features integration tests
//!
//! Tests for advanced features including real-time dashboard
//! and security hardening capabilities.

use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::time;

use router_flood::advanced_features::{
    AdvancedFeaturesRunner, AdvancedFeaturesConfig, init_advanced_features, 
    create_minimal_config, create_high_security_config
};
use router_flood::monitoring::{
    DashboardBuilder, AlertThresholds
};
use router_flood::security::{
    ThreatDetectionConfig, ValidationConfig, SecurityInputValidator,
    create_strict_validator, validate_ip_strict, validate_ports_strict
};

#[tokio::test]
async fn test_advanced_features_initialization() {
    let runner = init_advanced_features().expect("Failed to initialize advanced features");
    
    // Test that all components are properly initialized
    let security_context = runner.get_security_context();
    assert_eq!(security_context.threats_detected, 0);
    
    let monitoring_summary = runner.get_monitoring_summary();
    assert!(monitoring_summary.performance_score >= 0.0);
}

#[tokio::test]
async fn test_minimal_config() {
    let config = create_minimal_config();
    let runner = AdvancedFeaturesRunner::new(config).expect("Failed to create advanced features runner");
    
    // Test minimal configuration
    let security_context = runner.get_security_context();
    assert_eq!(security_context.threats_detected, 0);
}

#[tokio::test]
async fn test_high_security_config() {
    let config = create_high_security_config();
    let runner = AdvancedFeaturesRunner::new(config).expect("Failed to create advanced features runner");
    
    // Test high security configuration
    let security_context = runner.get_security_context();
    assert_eq!(security_context.threats_detected, 0);
}

#[tokio::test]
async fn test_configuration_validation() {
    let runner = init_advanced_features().expect("Failed to initialize advanced features");
    
    // Test valid configuration
    let valid_config = r#"
        target:
          ip: "192.168.1.1"
          ports: [80, 443]
        test:
          intensity: medium
          duration: 30
    "#;
    
    assert!(runner.validate_configuration(valid_config).is_ok());
    
    // Test configuration with suspicious patterns
    let suspicious_config = r#"
        target:
          ip: "192.168.1.1"
          ports: [80, 443]
        test:
          intensity: medium
          duration: 30
        # <script>alert('xss')</script>
    "#;
    
    // Should still pass but with warnings
    assert!(runner.validate_configuration(suspicious_config).is_ok());
}

#[tokio::test]
async fn test_ip_validation() {
    let runner = init_advanced_features().expect("Failed to initialize advanced features");
    
    // Test valid private IP
    assert!(runner.validate_target_ip("192.168.1.1").is_ok());
    assert!(runner.validate_target_ip("10.0.0.1").is_ok());
    assert!(runner.validate_target_ip("172.16.0.1").is_ok());
    
    // Test invalid public IP
    assert!(runner.validate_target_ip("8.8.8.8").is_err());
    assert!(runner.validate_target_ip("1.1.1.1").is_err());
    
    // Test invalid format
    assert!(runner.validate_target_ip("invalid.ip").is_err());
}

#[tokio::test]
async fn test_port_validation() {
    let runner = init_advanced_features().expect("Failed to initialize advanced features");
    
    // Test valid port list
    let valid_ports = vec![80, 443, 8080];
    assert!(runner.validate_ports(&valid_ports).is_ok());
    
    // Test empty port list
    let empty_ports = vec![];
    assert!(runner.validate_ports(&empty_ports).is_err());
    
    // Test excessive port list (should fail with high security)
    let excessive_ports: Vec<u16> = (1..=200).collect();
    let high_security_runner = AdvancedFeaturesRunner::new(create_high_security_config())
        .expect("Failed to create high security runner");
    assert!(high_security_runner.validate_ports(&excessive_ports).is_err());
}

#[tokio::test]
async fn test_security_input_validator() {
    let validator = create_strict_validator();
    
    // Test string validation
    let result = validator.validate_string("normal_string", "test_field");
    assert!(result.is_ok());
    let validated = result.unwrap();
    assert!(!validated.value.was_modified());
    assert!(validated.warnings.is_empty());
    
    // Test string with suspicious content
    let result = validator.validate_string("<script>alert('xss')</script>", "test_field");
    assert!(result.is_ok());
    let validated = result.unwrap();
    assert!(!validated.security_notes.is_empty());
    
    // Test filename validation
    let result = validator.validate_filename("valid_file.txt");
    assert!(result.is_ok());
    
    let result = validator.validate_filename("../../../etc/passwd");
    assert!(result.is_err());
}

#[tokio::test]
async fn test_ip_validation_strict() {
    // Test strict IP validation
    let result = validate_ip_strict("192.168.1.1");
    assert!(result.is_ok());
    let validated_ip = result.unwrap();
    assert!(validated_ip.is_private);
    
    let result = validate_ip_strict("8.8.8.8");
    assert!(result.is_err());
}

#[tokio::test]
async fn test_port_validation_strict() {
    // Test strict port validation
    let valid_ports = vec![80, 443];
    let result = validate_ports_strict(&valid_ports);
    assert!(result.is_ok());
    
    // Test excessive ports
    let excessive_ports: Vec<u16> = (1..=200).collect();
    let result = validate_ports_strict(&excessive_ports);
    assert!(result.is_err());
}

#[tokio::test]
async fn test_metrics_integration() {
    let runner = init_advanced_features().expect("Failed to initialize advanced features");
    let collector = runner.metrics_collector();
    
    // Record some test metrics
    collector.record_packet_sent(64);
    collector.record_packet_sent(128);
    collector.record_packet_failed();
    
    let metrics = collector.get_metrics();
    assert_eq!(metrics.packets_sent, 2);
    assert_eq!(metrics.packets_failed, 1);
    assert_eq!(metrics.bytes_sent, 192);
    
    // Test monitoring summary
    let summary = runner.get_monitoring_summary();
    assert!(summary.performance_score > 0.0);
}

#[tokio::test]
async fn test_dashboard_config_builder() {
    let config = DashboardBuilder::new()
        .update_interval(Duration::from_millis(500))
        .compact_mode(true)
        .show_progress_bar(false)
        .alert_thresholds(AlertThresholds {
            max_failure_rate: 5.0,
            min_success_rate: 95.0,
            max_response_time: 100.0,
            min_throughput: 10.0,
        })
        .build();
    
    assert_eq!(config.update_interval, Duration::from_millis(500));
    assert!(config.compact_mode);
    assert!(!config.show_progress_bar);
    assert_eq!(config.alert_thresholds.max_failure_rate, 5.0);
}

#[tokio::test]
async fn test_threat_detection_config() {
    let config = ThreatDetectionConfig {
        enable_rate_limiting: true,
        enable_input_validation: true,
        enable_anomaly_detection: false,
        max_requests_per_minute: 100,
        max_packet_size: 1500,
        max_target_ports: 50,
        suspicious_pattern_threshold: 10,
    };
    
    assert!(config.enable_rate_limiting);
    assert!(config.enable_input_validation);
    assert!(!config.enable_anomaly_detection);
    assert_eq!(config.max_requests_per_minute, 100);
}

#[tokio::test]
async fn test_validation_config() {
    let config = ValidationConfig {
        max_string_length: 512,
        max_array_size: 50,
        allow_special_chars: false,
        strict_ip_validation: true,
        enable_pattern_detection: true,
    };
    
    let validator = SecurityInputValidator::new(config);
    
    // Test with the configured limits
    let long_string = "a".repeat(600);
    let result = validator.validate_string(&long_string, "test");
    assert!(result.is_err()); // Should exceed max_string_length
}

#[tokio::test]
async fn test_export_report() {
    let runner = init_advanced_features().expect("Failed to initialize advanced features");
    
    // Record some test data
    let collector = runner.metrics_collector();
    collector.record_packet_sent(64);
    collector.record_packet_sent(128);
    
    // Export report
    let filename = "test_advanced_features_report.json";
    let result = runner.export_report(filename).await;
    assert!(result.is_ok());
    
    // Verify file exists
    assert!(tokio::fs::metadata(filename).await.is_ok());
    
    // Clean up
    let _ = tokio::fs::remove_file(filename).await;
}

#[tokio::test]
async fn test_security_context() {
    let runner = init_advanced_features().expect("Failed to initialize advanced features");
    
    let security_context = runner.get_security_context();
    assert_eq!(security_context.threats_detected, 0);
    assert_eq!(security_context.validation_failures, 0);
    
    // Security level should be safe initially
    use router_flood::advanced_features::SecurityLevel;
    assert_eq!(security_context.security_level, SecurityLevel::Safe);
}

#[tokio::test]
async fn test_advanced_features_start_stop() {
    let runner = init_advanced_features().expect("Failed to initialize advanced features");
    let running = Arc::new(AtomicBool::new(true));
    
    // Start advanced features in background
    let runner_clone = runner;
    let running_clone = Arc::clone(&running);
    
    let handle = tokio::spawn(async move {
        runner_clone.start(running_clone).await
    });
    
    // Let it run briefly
    time::sleep(Duration::from_millis(100)).await;
    
    // Stop it
    running.store(false, Ordering::Relaxed);
    
    // Wait for completion
    let result = tokio::time::timeout(Duration::from_secs(5), handle).await;
    assert!(result.is_ok());
    assert!(result.unwrap().is_ok());
}