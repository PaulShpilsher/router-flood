//! Unit tests for performance buffer pool module\n//!\n//! These tests were moved from src/performance/buffer_pool.rs to maintain\n//! separation between implementation and test code.\n\nuse router_flood::performance::buffer_pool::*;\nuse std::sync::{Arc, Barrier};\nuse std::thread;\n\n#[test]\nfn test_lock_free_buffer_pool() {\n    let pool = LockFreeBufferPool::new(1024, 10);\n    \n    // Test getting and returning buffers\n    let buffer1 = pool.get_buffer().unwrap();\n    assert_eq!(buffer1.len(), 1024);\n    \n    let buffer2 = pool.get_buffer().unwrap();\n    assert_eq!(buffer2.len(), 1024);\n    \n    pool.return_buffer(buffer1);\n    pool.return_buffer(buffer2);\n    \n    // Should be able to get buffers again\n    let buffer3 = pool.get_buffer().unwrap();\n    assert_eq!(buffer3.len(), 1024);\n}\n\n#[test]\nfn test_concurrent_access() {\n    let pool = Arc::new(LockFreeBufferPool::new(1024, 100));\n    let barrier = Arc::new(Barrier::new(10));\n    let mut handles = vec![];\n    \n    for _ in 0..10 {\n        let pool_clone = Arc::clone(&pool);\n        let barrier_clone = Arc::clone(&barrier);\n        \n        let handle = thread::spawn(move || {\n            barrier_clone.wait();\n            \n            // Each thread gets and returns 100 buffers\n            for _ in 0..100 {\n                if let Some(buffer) = pool_clone.get_buffer() {\n                    assert_eq!(buffer.len(), 1024);\n                    pool_clone.return_buffer(buffer);\n                }\n            }\n        });\n        \n        handles.push(handle);\n    }\n    \n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_shared_buffer_pool() {\n    let pool = SharedBufferPool::new(512, 5);\n    let pool_clone = pool.clone();\n    \n    let buffer = pool.get_buffer().unwrap();\n    assert_eq!(buffer.len(), 512);\n    \n    pool_clone.return_buffer(buffer);\n    \n    let buffer2 = pool.get_buffer().unwrap();\n    assert_eq!(buffer2.len(), 512);\n}\n"