//! Phase 5 - Advanced Features Integration\n//!\n//! This module integrates Phase 5 enhancements:\n//! 1. Lightweight real-time dashboard with essential metrics\n//! 2. Security hardening with threat detection and input validation\n//!\n//! Phase 5 focuses on advanced features while maintaining simplicity\n//! and following YAGNI principles.\n\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::time;\nuse tracing::{info, warn, error};\n\nuse crate::monitoring::{\n    RealtimeDashboard, DashboardConfig, DashboardBuilder, AlertThresholds,\n    SimpleMetricsCollector\n};\nuse crate::security::{\n    ThreatDetector, ThreatDetectionConfig, SecurityInputValidator,\n    ValidationConfig, CapabilityManager\n};\nuse crate::error::Result;\n\n/// Phase 5 enhanced application runner\npub struct Phase5Runner {\n    dashboard: Option<RealtimeDashboard>,\n    threat_detector: ThreatDetector,\n    input_validator: SecurityInputValidator,\n    capability_manager: CapabilityManager,\n    metrics_collector: Arc<SimpleMetricsCollector>,\n    config: Phase5Config,\n}\n\n/// Phase 5 configuration\n#[derive(Debug, Clone)]\npub struct Phase5Config {\n    pub enable_realtime_dashboard: bool,\n    pub enable_threat_detection: bool,\n    pub enable_enhanced_validation: bool,\n    pub dashboard_config: DashboardConfig,\n    pub threat_config: ThreatDetectionConfig,\n    pub validation_config: ValidationConfig,\n}\n\n/// Phase 5 security context\n#[derive(Debug)]\npub struct SecurityContext {\n    pub threats_detected: u64,\n    pub validation_failures: u64,\n    pub security_level: SecurityLevel,\n    pub last_threat_time: Option<String>,\n}\n\n/// Security level assessment\n#[derive(Debug, Clone, PartialEq)]\npub enum SecurityLevel {\n    Safe,\n    Elevated,\n    High,\n    Critical,\n}\n\n/// Phase 5 monitoring summary\n#[derive(Debug)]\npub struct MonitoringSummary {\n    pub dashboard_active: bool,\n    pub total_alerts: usize,\n    pub critical_alerts: usize,\n    pub uptime: Duration,\n    pub performance_score: f64,\n}\n\nimpl Default for Phase5Config {\n    fn default() -> Self {\n        Self {\n            enable_realtime_dashboard: true,\n            enable_threat_detection: true,\n            enable_enhanced_validation: true,\n            dashboard_config: DashboardBuilder::new()\n                .update_interval(Duration::from_secs(1))\n                .compact_mode(false)\n                .show_progress_bar(true)\n                .alert_thresholds(AlertThresholds {\n                    max_failure_rate: 5.0,\n                    min_success_rate: 95.0,\n                    max_response_time: 50.0,\n                    min_throughput: 10.0,\n                })\n                .build(),\n            threat_config: ThreatDetectionConfig {\n                enable_rate_limiting: true,\n                enable_input_validation: true,\n                enable_anomaly_detection: true,\n                max_requests_per_minute: 60,\n                max_packet_size: 65535,\n                max_target_ports: 100,\n                suspicious_pattern_threshold: 5,\n            },\n            validation_config: ValidationConfig {\n                max_string_length: 1024,\n                max_array_size: 100,\n                allow_special_chars: false,\n                strict_ip_validation: true,\n                enable_pattern_detection: true,\n            },\n        }\n    }\n}\n\nimpl Phase5Runner {\n    /// Create a new Phase 5 runner\n    pub fn new(config: Phase5Config) -> Result<Self> {\n        let metrics_collector = Arc::new(SimpleMetricsCollector::new());\n        \n        // Initialize threat detector\n        let threat_detector = ThreatDetector::new(config.threat_config.clone());\n        \n        // Initialize input validator\n        let input_validator = SecurityInputValidator::new(config.validation_config.clone());\n        \n        // Initialize capability manager\n        let capability_manager = CapabilityManager::new()?;\n        \n        // Initialize dashboard if enabled\n        let dashboard = if config.enable_realtime_dashboard {\n            Some(RealtimeDashboard::new(\n                Arc::clone(&metrics_collector),\n                config.dashboard_config.clone(),\n            ))\n        } else {\n            None\n        };\n        \n        Ok(Self {\n            dashboard,\n            threat_detector,\n            input_validator,\n            capability_manager,\n            metrics_collector,\n            config,\n        })\n    }\n\n    /// Start Phase 5 enhanced monitoring and security\n    pub async fn start(&self, running: Arc<AtomicBool>) -> Result<()> {\n        info!(\"🚀 Starting Phase 5 - Advanced Features\");\n        \n        // Display security context\n        self.display_security_status();\n        \n        // Start dashboard if enabled\n        if let Some(ref dashboard) = self.dashboard {\n            info!(\"📊 Starting real-time dashboard\");\n            let dashboard_running = Arc::clone(&running);\n            let dashboard_clone = dashboard.clone();\n            \n            tokio::spawn(async move {\n                dashboard_clone.start(dashboard_running).await;\n            });\n        }\n        \n        // Start security monitoring\n        if self.config.enable_threat_detection {\n            info!(\"🛡️ Starting threat detection\");\n            self.start_security_monitoring(Arc::clone(&running)).await;\n        }\n        \n        Ok(())\n    }\n\n    /// Validate configuration with Phase 5 security enhancements\n    pub fn validate_configuration(&self, config_data: &str) -> Result<()> {\n        if !self.config.enable_enhanced_validation {\n            return Ok(());\n        }\n        \n        info!(\"🔍 Validating configuration with enhanced security\");\n        \n        // Threat detection validation\n        let validation_result = self.threat_detector.validate_configuration(config_data)?;\n        \n        if !validation_result.is_valid {\n            error!(\"❌ Configuration validation failed due to security threats\");\n            for threat in &validation_result.threats {\n                warn!(\"🚨 Threat detected: {} - {}\", \n                    threat.threat_type_str(), threat.description);\n            }\n            return Err(crate::error::ValidationError::SystemRequirement(\n                \"Configuration contains security threats\"\n            ).into());\n        }\n        \n        if !validation_result.threats.is_empty() {\n            warn!(\"⚠️ {} security warnings detected in configuration\", \n                validation_result.threats.len());\n        }\n        \n        info!(\"✅ Configuration validation passed\");\n        Ok(())\n    }\n\n    /// Validate target IP with enhanced security\n    pub fn validate_target_ip(&self, ip_str: &str) -> Result<()> {\n        if !self.config.enable_enhanced_validation {\n            return Ok(());\n        }\n        \n        // Enhanced input validation\n        let validation_result = self.input_validator.validate_ip_address(ip_str)?;\n        \n        if !validation_result.warnings.is_empty() {\n            for warning in &validation_result.warnings {\n                warn!(\"⚠️ IP validation warning: {}\", warning);\n            }\n        }\n        \n        // Threat detection validation\n        self.threat_detector.validate_target_ip(&validation_result.value.addr)?;\n        \n        info!(\"✅ Target IP {} validated successfully\", ip_str);\n        Ok(())\n    }\n\n    /// Validate ports with enhanced security\n    pub fn validate_ports(&self, ports: &[u16]) -> Result<()> {\n        if !self.config.enable_enhanced_validation {\n            return Ok(());\n        }\n        \n        // Enhanced input validation\n        let validation_result = self.input_validator.validate_port_list(ports)?;\n        \n        if !validation_result.warnings.is_empty() {\n            for warning in &validation_result.warnings {\n                warn!(\"⚠️ Port validation warning: {}\", warning);\n            }\n        }\n        \n        // Threat detection validation\n        self.threat_detector.validate_ports(ports)?;\n        \n        info!(\"✅ {} ports validated successfully\", ports.len());\n        Ok(())\n    }\n\n    /// Get metrics collector for integration\n    pub fn metrics_collector(&self) -> Arc<SimpleMetricsCollector> {\n        Arc::clone(&self.metrics_collector)\n    }\n\n    /// Get security context\n    pub fn get_security_context(&self) -> SecurityContext {\n        let threat_summary = self.threat_detector.get_threat_summary();\n        \n        let security_level = match threat_summary.total_threats {\n            0 => SecurityLevel::Safe,\n            1..=5 => SecurityLevel::Elevated,\n            6..=20 => SecurityLevel::High,\n            _ => SecurityLevel::Critical,\n        };\n        \n        SecurityContext {\n            threats_detected: threat_summary.total_threats as u64,\n            validation_failures: 0, // Would be tracked in a real implementation\n            security_level,\n            last_threat_time: threat_summary.last_threat\n                .map(|t| t.timestamp),\n        }\n    }\n\n    /// Get monitoring summary\n    pub fn get_monitoring_summary(&self) -> MonitoringSummary {\n        let metrics = self.metrics_collector.get_metrics();\n        \n        // Calculate performance score based on success rate and throughput\n        let performance_score = (metrics.success_rate / 100.0) * \n            (metrics.packets_per_second / 100.0).min(1.0);\n        \n        MonitoringSummary {\n            dashboard_active: self.dashboard.is_some(),\n            total_alerts: 0, // Would be tracked from dashboard\n            critical_alerts: 0,\n            uptime: Duration::from_secs_f64(metrics.duration_secs),\n            performance_score,\n        }\n    }\n\n    /// Display security status\n    fn display_security_status(&self) {\n        println!(\"🔒 Phase 5 Security Status\");\n        println!(\"═══════════════════════════\");\n        \n        // Capability status\n        let security_context = self.capability_manager.security_context();\n        println!(\"Process ID: {}\", security_context.process_id);\n        println!(\"Effective UID: {}\", security_context.effective_uid);\n        println!(\"CAP_NET_RAW: {}\", \n            if security_context.has_net_raw { \"✅\" } else { \"❌\" });\n        \n        // Feature status\n        println!(\"\\n🛡️ Security Features:\");\n        println!(\"Real-time Dashboard: {}\", \n            if self.config.enable_realtime_dashboard { \"✅ Enabled\" } else { \"❌ Disabled\" });\n        println!(\"Threat Detection: {}\", \n            if self.config.enable_threat_detection { \"✅ Enabled\" } else { \"❌ Disabled\" });\n        println!(\"Enhanced Validation: {}\", \n            if self.config.enable_enhanced_validation { \"✅ Enabled\" } else { \"❌ Disabled\" });\n        \n        println!();\n    }\n\n    /// Start security monitoring background task\n    async fn start_security_monitoring(&self, running: Arc<AtomicBool>) {\n        let mut interval = time::interval(Duration::from_secs(30));\n        \n        while running.load(Ordering::Relaxed) {\n            interval.tick().await;\n            \n            // Check for anomalies\n            let metrics = self.metrics_collector.get_metrics();\n            let anomalies = self.threat_detector.check_anomalies(\n                metrics.packets_per_second,\n                metrics.bytes_sent as f64 / metrics.packets_sent.max(1) as f64,\n            );\n            \n            if !anomalies.is_empty() {\n                warn!(\"🚨 {} anomalies detected\", anomalies.len());\n                for anomaly in anomalies {\n                    warn!(\"   - {}\", anomaly.description);\n                }\n            }\n            \n            // Log security status periodically\n            let security_context = self.get_security_context();\n            if security_context.threats_detected > 0 {\n                info!(\"🛡️ Security status: {} threats detected, level: {:?}\", \n                    security_context.threats_detected, security_context.security_level);\n            }\n        }\n    }\n\n    /// Export security and monitoring report\n    pub async fn export_report(&self, filename: &str) -> Result<()> {\n        let security_context = self.get_security_context();\n        let monitoring_summary = self.get_monitoring_summary();\n        let threat_summary = self.threat_detector.get_threat_summary();\n        \n        let report = serde_json::json!({\n            \"phase5_report\": {\n                \"timestamp\": chrono::Utc::now().to_rfc3339(),\n                \"security_context\": {\n                    \"threats_detected\": security_context.threats_detected,\n                    \"security_level\": format!(\"{:?}\", security_context.security_level),\n                    \"last_threat_time\": security_context.last_threat_time\n                },\n                \"monitoring_summary\": {\n                    \"dashboard_active\": monitoring_summary.dashboard_active,\n                    \"uptime_seconds\": monitoring_summary.uptime.as_secs(),\n                    \"performance_score\": monitoring_summary.performance_score\n                },\n                \"threat_summary\": threat_summary,\n                \"metrics\": self.metrics_collector.get_metrics()\n            }\n        });\n        \n        let json = serde_json::to_string_pretty(&report)\n            .map_err(|e| crate::error::StatsError::SerializationError(e.to_string()))?;\n        \n        tokio::fs::write(filename, json).await\n            .map_err(|e| crate::error::StatsError::FileWriteError(e.to_string()))?;\n        \n        info!(\"📄 Phase 5 report exported to {}\", filename);\n        Ok(())\n    }\n}\n\n/// Initialize Phase 5 with default configuration\npub fn init_phase5() -> Result<Phase5Runner> {\n    let config = Phase5Config::default();\n    Phase5Runner::new(config)\n}\n\n/// Initialize Phase 5 with custom configuration\npub fn init_phase5_with_config(config: Phase5Config) -> Result<Phase5Runner> {\n    Phase5Runner::new(config)\n}\n\n/// Create a minimal Phase 5 configuration for testing\npub fn create_minimal_config() -> Phase5Config {\n    Phase5Config {\n        enable_realtime_dashboard: false,\n        enable_threat_detection: true,\n        enable_enhanced_validation: true,\n        dashboard_config: DashboardBuilder::new()\n            .compact_mode(true)\n            .build(),\n        threat_config: ThreatDetectionConfig {\n            enable_rate_limiting: false,\n            enable_input_validation: true,\n            enable_anomaly_detection: false,\n            max_requests_per_minute: 1000,\n            max_packet_size: 65535,\n            max_target_ports: 1000,\n            suspicious_pattern_threshold: 100,\n        },\n        validation_config: ValidationConfig::default(),\n    }\n}\n\n/// Create a high-security Phase 5 configuration\npub fn create_high_security_config() -> Phase5Config {\n    Phase5Config {\n        enable_realtime_dashboard: true,\n        enable_threat_detection: true,\n        enable_enhanced_validation: true,\n        dashboard_config: DashboardBuilder::new()\n            .update_interval(Duration::from_millis(500))\n            .alert_thresholds(AlertThresholds {\n                max_failure_rate: 1.0,\n                min_success_rate: 99.0,\n                max_response_time: 10.0,\n                min_throughput: 50.0,\n            })\n            .build(),\n        threat_config: ThreatDetectionConfig {\n            enable_rate_limiting: true,\n            enable_input_validation: true,\n            enable_anomaly_detection: true,\n            max_requests_per_minute: 30,\n            max_packet_size: 1500,\n            max_target_ports: 10,\n            suspicious_pattern_threshold: 1,\n        },\n        validation_config: ValidationConfig {\n            max_string_length: 256,\n            max_array_size: 10,\n            allow_special_chars: false,\n            strict_ip_validation: true,\n            enable_pattern_detection: true,\n        },\n    }\n}\n"