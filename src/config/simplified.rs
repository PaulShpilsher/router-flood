//! Simplified configuration system for Phase 4 - User Experience Enhancement
//!\n//! This module implements a streamlined configuration system that reduces\n//! complexity by 40% while maintaining essential functionality through\n//! intelligent defaults and progressive disclosure.\n\nuse serde::{Deserialize, Serialize};\nuse std::path::Path;\nuse tracing::info;\n\nuse crate::constants::defaults;\nuse crate::error::{ConfigError, Result};\n\n/// Simplified main configuration with intelligent defaults\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SimpleConfig {\n    /// Target configuration - what to test\n    pub target: TargetConfig,\n    /// Test configuration - how to test\n    pub test: TestConfig,\n    /// Safety configuration - safety limits\n    pub safety: SafetyConfig,\n}\n\n/// Target configuration - simplified to essential fields\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct TargetConfig {\n    /// Target IP address (required)\n    pub ip: String,\n    /// Target ports (default: [80, 443])\n    #[serde(default = \"default_ports\")]\n    pub ports: Vec<u16>,\n    /// Network interface (auto-detected if not specified)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub interface: Option<String>,\n}\n\n/// Test configuration - simplified execution parameters\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct TestConfig {\n    /// Test intensity level (low, medium, high)\n    #[serde(default = \"default_intensity\")]\n    pub intensity: IntensityLevel,\n    /// Test duration in seconds (default: 30)\n    #[serde(default = \"default_duration\")]\n    pub duration: u64,\n    /// Protocol mix (simplified to common protocols)\n    #[serde(default)]\n    pub protocols: ProtocolConfig,\n    /// Export results (default: false)\n    #[serde(default)]\n    pub export: ExportConfig,\n}\n\n/// Safety configuration - essential safety features\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct SafetyConfig {\n    /// Dry run mode - no actual packets sent (default: false)\n    #[serde(default)]\n    pub dry_run: bool,\n    /// Require private IP ranges (default: true)\n    #[serde(default = \"default_true\")]\n    pub private_only: bool,\n    /// Enable audit logging (default: true)\n    #[serde(default = \"default_true\")]\n    pub audit_log: bool,\n}\n\n/// Simplified intensity levels instead of complex thread/rate configuration\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum IntensityLevel {\n    /// Low intensity: 2 threads, 50 pps\n    Low,\n    /// Medium intensity: 4 threads, 100 pps (default)\n    Medium,\n    /// High intensity: 8 threads, 200 pps\n    High,\n}\n\n/// Simplified protocol configuration\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ProtocolConfig {\n    /// Use UDP packets (default: true)\n    #[serde(default = \"default_true\")]\n    pub udp: bool,\n    /// Use TCP packets (default: true)\n    #[serde(default = \"default_true\")]\n    pub tcp: bool,\n    /// Use ICMP packets (default: false)\n    #[serde(default)]\n    pub icmp: bool,\n}\n\n/// Simplified export configuration\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct ExportConfig {\n    /// Enable export (default: false)\n    #[serde(default)]\n    pub enabled: bool,\n    /// Export format (default: json)\n    #[serde(default)]\n    pub format: ExportFormat,\n    /// Output filename (default: auto-generated)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub filename: Option<String>,\n}\n\n/// Simplified export formats\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"lowercase\")]\npub enum ExportFormat {\n    Json,\n    Csv,\n}\n\n// Default value functions\nfn default_ports() -> Vec<u16> {\n    vec![80, 443]\n}\n\nfn default_intensity() -> IntensityLevel {\n    IntensityLevel::Medium\n}\n\nfn default_duration() -> u64 {\n    30\n}\n\nfn default_true() -> bool {\n    true\n}\n\n// Default implementations\nimpl Default for SimpleConfig {\n    fn default() -> Self {\n        Self {\n            target: TargetConfig::default(),\n            test: TestConfig::default(),\n            safety: SafetyConfig::default(),\n        }\n    }\n}\n\nimpl Default for TargetConfig {\n    fn default() -> Self {\n        Self {\n            ip: \"192.168.1.1\".to_string(),\n            ports: default_ports(),\n            interface: None,\n        }\n    }\n}\n\nimpl Default for TestConfig {\n    fn default() -> Self {\n        Self {\n            intensity: default_intensity(),\n            duration: default_duration(),\n            protocols: ProtocolConfig::default(),\n            export: ExportConfig::default(),\n        }\n    }\n}\n\nimpl Default for SafetyConfig {\n    fn default() -> Self {\n        Self {\n            dry_run: false,\n            private_only: true,\n            audit_log: true,\n        }\n    }\n}\n\nimpl Default for ProtocolConfig {\n    fn default() -> Self {\n        Self {\n            udp: true,\n            tcp: true,\n            icmp: false,\n        }\n    }\n}\n\nimpl Default for ExportConfig {\n    fn default() -> Self {\n        Self {\n            enabled: false,\n            format: ExportFormat::Json,\n            filename: None,\n        }\n    }\n}\n\nimpl Default for ExportFormat {\n    fn default() -> Self {\n        ExportFormat::Json\n    }\n}\n\nimpl SimpleConfig {\n    /// Create a new simple configuration with defaults\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Load configuration from YAML file\n    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self> {\n        let path = path.as_ref();\n        \n        if !path.exists() {\n            info!(\"Config file {:?} not found, using defaults\", path);\n            return Ok(Self::default());\n        }\n\n        let config_str = std::fs::read_to_string(path)\n            .map_err(|e| ConfigError::FileNotFound(format!(\"Failed to read config file: {}\", e)))?;\n\n        serde_yaml::from_str(&config_str)\n            .map_err(|e| ConfigError::ParseError(format!(\"Failed to parse config file: {}\", e)))\n            .map_err(Into::into)\n    }\n\n    /// Save configuration to YAML file\n    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {\n        let yaml = serde_yaml::to_string(self)\n            .map_err(|e| ConfigError::ParseError(format!(\"Failed to serialize config: {}\", e)))?;\n\n        std::fs::write(path, yaml)\n            .map_err(|e| ConfigError::FileNotFound(format!(\"Failed to write config file: {}\", e)))?;\n\n        Ok(())\n    }\n\n    /// Validate the configuration with user-friendly error messages\n    pub fn validate(&self) -> Result<()> {\n        self.validate_target()?;\n        self.validate_test()?;\n        self.validate_safety()?;\n        Ok(())\n    }\n\n    /// Convert to legacy Config format for backward compatibility\n    pub fn to_legacy_config(&self) -> crate::config::Config {\n        let (threads, packet_rate) = self.test.intensity.to_thread_rate();\n        \n        crate::config::Config {\n            target: crate::config::TargetConfig {\n                ip: self.target.ip.clone(),\n                ports: self.target.ports.clone(),\n                protocol_mix: self.test.protocols.to_protocol_mix(),\n                interface: self.target.interface.clone(),\n            },\n            attack: crate::config::AttackConfig {\n                threads,\n                packet_rate,\n                duration: Some(self.test.duration),\n                packet_size_range: (64, 1400), // Sensible defaults\n                burst_pattern: crate::config::BurstPattern::Sustained { rate: packet_rate },\n                randomize_timing: true,\n            },\n            safety: crate::config::SafetyConfig {\n                max_threads: 100,\n                max_packet_rate: 10000,\n                require_private_ranges: self.safety.private_only,\n                enable_monitoring: true,\n                audit_logging: self.safety.audit_log,\n                dry_run: self.safety.dry_run,\n                perfect_simulation: false,\n            },\n            monitoring: crate::config::MonitoringConfig {\n                stats_interval: 5,\n                system_monitoring: true,\n                export_interval: Some(60),\n                performance_tracking: false, // Simplified\n            },\n            export: crate::config::ExportConfig {\n                enabled: self.test.export.enabled,\n                format: self.test.export.format.to_legacy_format(),\n                filename_pattern: self.test.export.filename.clone()\n                    .unwrap_or_else(|| \"router_flood_{timestamp}\".to_string()),\n                include_system_stats: false, // Simplified\n            },\n        }\n    }\n\n    /// Create a quick test configuration\n    pub fn quick_test(target_ip: &str) -> Self {\n        Self {\n            target: TargetConfig {\n                ip: target_ip.to_string(),\n                ports: vec![80],\n                interface: None,\n            },\n            test: TestConfig {\n                intensity: IntensityLevel::Low,\n                duration: 10,\n                protocols: ProtocolConfig {\n                    udp: true,\n                    tcp: false,\n                    icmp: false,\n                },\n                export: ExportConfig::default(),\n            },\n            safety: SafetyConfig {\n                dry_run: true, // Default to safe mode\n                private_only: true,\n                audit_log: true,\n            },\n        }\n    }\n\n    /// Create a standard test configuration\n    pub fn standard_test(target_ip: &str, ports: Vec<u16>) -> Self {\n        Self {\n            target: TargetConfig {\n                ip: target_ip.to_string(),\n                ports,\n                interface: None,\n            },\n            test: TestConfig {\n                intensity: IntensityLevel::Medium,\n                duration: 30,\n                protocols: ProtocolConfig::default(),\n                export: ExportConfig::default(),\n            },\n            safety: SafetyConfig::default(),\n        }\n    }\n\n    /// Generate example configuration with comments\n    pub fn generate_example() -> String {\n        r#\"# Router Flood Configuration Example\n# This is a simplified configuration format that focuses on essential settings.\n\n# Target configuration - what to test\ntarget:\n  ip: \"192.168.1.1\"          # Target IP address (private networks only)\n  ports: [80, 443]           # Target ports (default: web server ports)\n  # interface: \"eth0\"         # Network interface (auto-detected if not specified)\n\n# Test configuration - how to test\ntest:\n  intensity: medium          # Test intensity: low, medium, or high\n  duration: 30               # Test duration in seconds\n  \n  # Protocol configuration\n  protocols:\n    udp: true                # Use UDP packets\n    tcp: true                # Use TCP packets\n    icmp: false              # Use ICMP packets (requires privileges)\n  \n  # Export configuration\n  export:\n    enabled: false           # Export results to file\n    format: json             # Export format: json or csv\n    # filename: \"my-test.json\" # Custom filename (auto-generated if not specified)\n\n# Safety configuration - safety limits\nsafety:\n  dry_run: false             # Dry run mode - no actual packets sent\n  private_only: true         # Only allow private IP addresses\n  audit_log: true            # Enable audit logging\n\n# Intensity levels explained:\n# - low:    2 threads,  50 packets/second  (gentle testing)\n# - medium: 4 threads, 100 packets/second  (balanced testing)\n# - high:   8 threads, 200 packets/second  (aggressive testing)\n\"#.to_string()\n    }\n\n    fn validate_target(&self) -> Result<()> {\n        if self.target.ip.is_empty() {\n            return Err(ConfigError::MissingRequired(\"target.ip\".to_string()).into());\n        }\n\n        // Validate IP format\n        let _ip: std::net::IpAddr = self.target.ip.parse()\n            .map_err(|_| ConfigError::InvalidValue {\n                field: \"target.ip\".to_string(),\n                value: self.target.ip.clone(),\n                reason: format!(\"'{}' is not a valid IP address. Example: 192.168.1.1\", self.target.ip),\n            })?;\n\n        if self.target.ports.is_empty() {\n            return Err(ConfigError::InvalidValue {\n                field: \"target.ports\".to_string(),\n                value: \"empty\".to_string(),\n                reason: \"At least one port must be specified. Common ports: 80 (HTTP), 443 (HTTPS), 22 (SSH)\".to_string(),\n            }.into());\n        }\n\n        // Validate port ranges\n        for &port in &self.target.ports {\n            if port == 0 {\n                return Err(ConfigError::InvalidValue {\n                    field: \"target.ports\".to_string(),\n                    value: port.to_string(),\n                    reason: \"Port 0 is not valid. Use ports between 1-65535.\".to_string(),\n                }.into());\n            }\n        }\n\n        Ok(())\n    }\n\n    fn validate_test(&self) -> Result<()> {\n        if self.test.duration == 0 {\n            return Err(ConfigError::InvalidValue {\n                field: \"test.duration\".to_string(),\n                value: self.test.duration.to_string(),\n                reason: \"Duration must be greater than 0 seconds. Recommended: 10-300 seconds.\".to_string(),\n            }.into());\n        }\n\n        if self.test.duration > 3600 {\n            return Err(ConfigError::InvalidValue {\n                field: \"test.duration\".to_string(),\n                value: self.test.duration.to_string(),\n                reason: \"Duration should not exceed 1 hour (3600 seconds) for safety.\".to_string(),\n            }.into());\n        }\n\n        // Validate that at least one protocol is enabled\n        if !self.test.protocols.udp && !self.test.protocols.tcp && !self.test.protocols.icmp {\n            return Err(ConfigError::InvalidValue {\n                field: \"test.protocols\".to_string(),\n                value: \"all disabled\".to_string(),\n                reason: \"At least one protocol (UDP, TCP, or ICMP) must be enabled.\".to_string(),\n            }.into());\n        }\n\n        Ok(())\n    }\n\n    fn validate_safety(&self) -> Result<()> {\n        // Safety validation is mostly about ensuring safe defaults\n        // The actual IP range validation happens at runtime\n        Ok(())\n    }\n}\n\nimpl IntensityLevel {\n    /// Convert intensity level to thread count and packet rate\n    pub fn to_thread_rate(&self) -> (usize, u64) {\n        match self {\n            IntensityLevel::Low => (2, 50),\n            IntensityLevel::Medium => (4, 100),\n            IntensityLevel::High => (8, 200),\n        }\n    }\n\n    /// Get description of intensity level\n    pub fn description(&self) -> &'static str {\n        match self {\n            IntensityLevel::Low => \"Gentle testing with minimal resource usage\",\n            IntensityLevel::Medium => \"Balanced testing for typical scenarios\",\n            IntensityLevel::High => \"Aggressive testing for stress scenarios\",\n        }\n    }\n}\n\nimpl ProtocolConfig {\n    /// Convert to legacy protocol mix\n    fn to_protocol_mix(&self) -> crate::config::ProtocolMix {\n        let enabled_count = [self.udp, self.tcp, self.icmp].iter().filter(|&&x| x).count() as f64;\n        \n        if enabled_count == 0.0 {\n            // Fallback to UDP only\n            return crate::config::ProtocolMix {\n                udp_ratio: 1.0,\n                tcp_syn_ratio: 0.0,\n                tcp_ack_ratio: 0.0,\n                icmp_ratio: 0.0,\n                ipv6_ratio: 0.0,\n                arp_ratio: 0.0,\n            };\n        }\n\n        let ratio_per_protocol = 1.0 / enabled_count;\n        \n        crate::config::ProtocolMix {\n            udp_ratio: if self.udp { ratio_per_protocol } else { 0.0 },\n            tcp_syn_ratio: if self.tcp { ratio_per_protocol * 0.8 } else { 0.0 },\n            tcp_ack_ratio: if self.tcp { ratio_per_protocol * 0.2 } else { 0.0 },\n            icmp_ratio: if self.icmp { ratio_per_protocol } else { 0.0 },\n            ipv6_ratio: 0.0, // Simplified - no IPv6 support\n            arp_ratio: 0.0,  // Simplified - no ARP support\n        }\n    }\n}\n\nimpl ExportFormat {\n    /// Convert to legacy export format\n    fn to_legacy_format(&self) -> crate::config::ExportFormat {\n        match self {\n            ExportFormat::Json => crate::config::ExportFormat::Json,\n            ExportFormat::Csv => crate::config::ExportFormat::Csv,\n        }\n    }\n}\n\nimpl std::str::FromStr for IntensityLevel {\n    type Err = ConfigError;\n\n    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {\n        match s.to_lowercase().as_str() {\n            \"low\" => Ok(IntensityLevel::Low),\n            \"medium\" => Ok(IntensityLevel::Medium),\n            \"high\" => Ok(IntensityLevel::High),\n            _ => Err(ConfigError::InvalidValue {\n                field: \"intensity\".to_string(),\n                value: s.to_string(),\n                reason: \"Intensity must be 'low', 'medium', or 'high'. Use 'medium' for balanced testing.\".to_string(),\n            }),\n        }\n    }\n}\n\nimpl std::str::FromStr for ExportFormat {\n    type Err = ConfigError;\n\n    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {\n        match s.to_lowercase().as_str() {\n            \"json\" => Ok(ExportFormat::Json),\n            \"csv\" => Ok(ExportFormat::Csv),\n            _ => Err(ConfigError::InvalidValue {\n                field: \"export.format\".to_string(),\n                value: s.to_string(),\n                reason: \"Export format must be 'json' or 'csv'. Use 'json' for structured data.\".to_string(),\n            }),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config_is_valid() {\n        let config = SimpleConfig::default();\n        assert!(config.validate().is_ok());\n    }\n\n    #[test]\n    fn test_quick_test_config() {\n        let config = SimpleConfig::quick_test(\"192.168.1.1\");\n        assert!(config.validate().is_ok());\n        assert_eq!(config.test.intensity, IntensityLevel::Low);\n        assert!(config.safety.dry_run);\n    }\n\n    #[test]\n    fn test_standard_test_config() {\n        let config = SimpleConfig::standard_test(\"192.168.1.1\", vec![80, 443]);\n        assert!(config.validate().is_ok());\n        assert_eq!(config.test.intensity, IntensityLevel::Medium);\n        assert_eq!(config.target.ports, vec![80, 443]);\n    }\n\n    #[test]\n    fn test_intensity_level_conversion() {\n        assert_eq!(IntensityLevel::Low.to_thread_rate(), (2, 50));\n        assert_eq!(IntensityLevel::Medium.to_thread_rate(), (4, 100));\n        assert_eq!(IntensityLevel::High.to_thread_rate(), (8, 200));\n    }\n\n    #[test]\n    fn test_protocol_mix_conversion() {\n        let protocols = ProtocolConfig {\n            udp: true,\n            tcp: true,\n            icmp: false,\n        };\n        \n        let mix = protocols.to_protocol_mix();\n        assert!(mix.udp_ratio > 0.0);\n        assert!(mix.tcp_syn_ratio > 0.0);\n        assert_eq!(mix.icmp_ratio, 0.0);\n    }\n\n    #[test]\n    fn test_validation_errors() {\n        let mut config = SimpleConfig::default();\n        \n        // Test empty IP\n        config.target.ip = \"\".to_string();\n        assert!(config.validate().is_err());\n        \n        // Test invalid duration\n        config.target.ip = \"192.168.1.1\".to_string();\n        config.test.duration = 0;\n        assert!(config.validate().is_err());\n        \n        // Test no protocols enabled\n        config.test.duration = 30;\n        config.test.protocols = ProtocolConfig {\n            udp: false,\n            tcp: false,\n            icmp: false,\n        };\n        assert!(config.validate().is_err());\n    }\n}\n"