//! Lightweight real-time dashboard for Phase 5 monitoring enhancements\n//!\n//! This module provides a minimal, efficient real-time dashboard that focuses\n//! on essential metrics without over-engineering, following YAGNI principles.\n\nuse std::sync::atomic::{AtomicBool, AtomicU64, Ordering};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::time;\nuse serde::{Deserialize, Serialize};\n\nuse crate::monitoring::simplified::{EssentialMetrics, SimpleMetricsCollector};\nuse crate::utils::shared::{format_bytes, format_duration};\n\n/// Lightweight real-time dashboard\npub struct RealtimeDashboard {\n    collector: Arc<SimpleMetricsCollector>,\n    config: DashboardConfig,\n    start_time: Instant,\n    last_update: Arc<AtomicU64>,\n}\n\n/// Dashboard configuration\n#[derive(Debug, Clone)]\npub struct DashboardConfig {\n    pub update_interval: Duration,\n    pub show_system_info: bool,\n    pub show_progress_bar: bool,\n    pub compact_mode: bool,\n    pub alert_thresholds: AlertThresholds,\n}\n\n/// Alert thresholds for monitoring\n#[derive(Debug, Clone)]\npub struct AlertThresholds {\n    pub max_failure_rate: f64,    // Percentage\n    pub min_success_rate: f64,    // Percentage\n    pub max_response_time: f64,   // Milliseconds\n    pub min_throughput: f64,      // Packets per second\n}\n\n/// Real-time dashboard state\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DashboardState {\n    pub timestamp: String,\n    pub uptime: String,\n    pub metrics: EssentialMetrics,\n    pub alerts: Vec<Alert>,\n    pub system_info: Option<SystemInfo>,\n}\n\n/// System information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SystemInfo {\n    pub cpu_usage: f64,\n    pub memory_usage: f64,\n    pub network_utilization: f64,\n}\n\n/// Alert information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Alert {\n    pub level: AlertLevel,\n    pub message: String,\n    pub timestamp: String,\n}\n\n/// Alert severity levels\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum AlertLevel {\n    Info,\n    Warning,\n    Critical,\n}\n\nimpl Default for DashboardConfig {\n    fn default() -> Self {\n        Self {\n            update_interval: Duration::from_secs(1),\n            show_system_info: false,\n            show_progress_bar: true,\n            compact_mode: false,\n            alert_thresholds: AlertThresholds::default(),\n        }\n    }\n}\n\nimpl Default for AlertThresholds {\n    fn default() -> Self {\n        Self {\n            max_failure_rate: 10.0,   // 10% failure rate triggers warning\n            min_success_rate: 95.0,   // Below 95% success rate triggers warning\n            max_response_time: 100.0, // Above 100ms response time triggers info\n            min_throughput: 10.0,     // Below 10 pps triggers info\n        }\n    }\n}\n\nimpl RealtimeDashboard {\n    /// Create a new real-time dashboard\n    pub fn new(collector: Arc<SimpleMetricsCollector>, config: DashboardConfig) -> Self {\n        Self {\n            collector,\n            config,\n            start_time: Instant::now(),\n            last_update: Arc::new(AtomicU64::new(0)),\n        }\n    }\n\n    /// Start the real-time dashboard\n    pub async fn start(&self, running: Arc<AtomicBool>) {\n        let mut interval = time::interval(self.config.update_interval);\n        \n        // Clear screen and show header\n        if !self.config.compact_mode {\n            self.clear_screen();\n            self.show_header();\n        }\n        \n        while running.load(Ordering::Relaxed) {\n            interval.tick().await;\n            self.update_display().await;\n        }\n        \n        // Show final summary\n        if !self.config.compact_mode {\n            self.show_final_summary();\n        }\n    }\n\n    /// Update the dashboard display\n    async fn update_display(&self) {\n        let state = self.get_dashboard_state().await;\n        \n        if self.config.compact_mode {\n            self.display_compact(&state);\n        } else {\n            self.display_full(&state);\n        }\n        \n        // Update last update timestamp\n        self.last_update.store(\n            std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap_or_default()\n                .as_secs(),\n            Ordering::Relaxed,\n        );\n    }\n\n    /// Get current dashboard state\n    async fn get_dashboard_state(&self) -> DashboardState {\n        let metrics = self.collector.get_metrics();\n        let uptime = self.start_time.elapsed();\n        let alerts = self.check_alerts(&metrics);\n        let system_info = if self.config.show_system_info {\n            Some(self.get_system_info().await)\n        } else {\n            None\n        };\n\n        DashboardState {\n            timestamp: chrono::Utc::now().format(\"%H:%M:%S\").to_string(),\n            uptime: format_duration(uptime),\n            metrics,\n            alerts,\n            system_info,\n        }\n    }\n\n    /// Check for alerts based on current metrics\n    fn check_alerts(&self, metrics: &EssentialMetrics) -> Vec<Alert> {\n        let mut alerts = Vec::new();\n        let now = chrono::Utc::now().format(\"%H:%M:%S\").to_string();\n        \n        // Check failure rate\n        let failure_rate = if metrics.packets_sent + metrics.packets_failed > 0 {\n            (metrics.packets_failed as f64 / (metrics.packets_sent + metrics.packets_failed) as f64) * 100.0\n        } else {\n            0.0\n        };\n        \n        if failure_rate > self.config.alert_thresholds.max_failure_rate {\n            alerts.push(Alert {\n                level: AlertLevel::Warning,\n                message: format!(\"High failure rate: {:.1}%\", failure_rate),\n                timestamp: now.clone(),\n            });\n        }\n        \n        // Check success rate\n        if metrics.success_rate < self.config.alert_thresholds.min_success_rate {\n            alerts.push(Alert {\n                level: AlertLevel::Warning,\n                message: format!(\"Low success rate: {:.1}%\", metrics.success_rate),\n                timestamp: now.clone(),\n            });\n        }\n        \n        // Check throughput\n        if metrics.packets_per_second < self.config.alert_thresholds.min_throughput {\n            alerts.push(Alert {\n                level: AlertLevel::Info,\n                message: format!(\"Low throughput: {:.1} pps\", metrics.packets_per_second),\n                timestamp: now,\n            });\n        }\n        \n        alerts\n    }\n\n    /// Get basic system information\n    async fn get_system_info(&self) -> SystemInfo {\n        // Simplified system info - in a real implementation, this would\n        // use system monitoring libraries like sysinfo\n        SystemInfo {\n            cpu_usage: 0.0,\n            memory_usage: 0.0,\n            network_utilization: 0.0,\n        }\n    }\n\n    /// Display compact dashboard\n    fn display_compact(&self, state: &DashboardState) {\n        let status_icon = if state.alerts.is_empty() { \"âœ…\" } else { \"âš ï¸\" };\n        \n        print!(\"\\r{} [{}] Sent: {} | Failed: {} | Rate: {:.1} pps | Success: {:.1}% | {}\",\n            status_icon,\n            state.timestamp,\n            state.metrics.packets_sent,\n            state.metrics.packets_failed,\n            state.metrics.packets_per_second,\n            state.metrics.success_rate,\n            state.uptime\n        );\n        \n        // Flush stdout to ensure immediate display\n        use std::io::{self, Write};\n        let _ = io::stdout().flush();\n    }\n\n    /// Display full dashboard\n    fn display_full(&self, state: &DashboardState) {\n        // Move cursor to top and clear screen content\n        print!(\"\\x1b[H\");\n        \n        // Dashboard header\n        println!(\"ðŸš€ Router Flood - Real-time Dashboard\");\n        println!(\"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n        println!(\"Time: {} | Uptime: {}\", state.timestamp, state.uptime);\n        println!();\n        \n        // Core metrics\n        println!(\"ðŸ“Š Core Metrics\");\n        println!(\"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\");\n        println!(\"Packets Sent:     {:>10}\", state.metrics.packets_sent);\n        println!(\"Packets Failed:   {:>10}\", state.metrics.packets_failed);\n        println!(\"Success Rate:     {:>9.1}%\", state.metrics.success_rate);\n        println!(\"Data Sent:        {:>10}\", format_bytes(state.metrics.bytes_sent));\n        println!();\n        \n        // Performance metrics\n        println!(\"âš¡ Performance\");\n        println!(\"â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\");\n        println!(\"Rate:             {:>9.1} pps\", state.metrics.packets_per_second);\n        println!(\"Bandwidth:        {:>9.2} Mbps\", state.metrics.bandwidth_mbps);\n        println!(\"Duration:         {:>10}\", format_duration(Duration::from_secs_f64(state.metrics.duration_secs)));\n        \n        // Progress bar\n        if self.config.show_progress_bar {\n            println!();\n            self.display_progress_bar(&state.metrics);\n        }\n        \n        // System info\n        if let Some(ref sys_info) = state.system_info {\n            println!();\n            println!(\"ðŸ’» System\");\n            println!(\"â”€â”€â”€â”€â”€â”€â”€â”€â”€\");\n            println!(\"CPU Usage:        {:>9.1}%\", sys_info.cpu_usage);\n            println!(\"Memory Usage:     {:>9.1}%\", sys_info.memory_usage);\n            println!(\"Network:          {:>9.1}%\", sys_info.network_utilization);\n        }\n        \n        // Alerts\n        if !state.alerts.is_empty() {\n            println!();\n            println!(\"ðŸš¨ Alerts\");\n            println!(\"â”€â”€â”€â”€â”€â”€â”€â”€â”€\");\n            for alert in &state.alerts {\n                let icon = match alert.level {\n                    AlertLevel::Info => \"â„¹ï¸\",\n                    AlertLevel::Warning => \"âš ï¸\",\n                    AlertLevel::Critical => \"ðŸš¨\",\n                };\n                println!(\"{} [{}] {}\", icon, alert.timestamp, alert.message);\n            }\n        }\n        \n        // Footer\n        println!();\n        println!(\"Press Ctrl+C to stop\");\n        \n        // Clear any remaining lines\n        print!(\"\\x1b[J\");\n    }\n\n    /// Display a simple progress bar\n    fn display_progress_bar(&self, metrics: &EssentialMetrics) {\n        let width = 40;\n        let success_ratio = metrics.success_rate / 100.0;\n        let filled = (width as f64 * success_ratio) as usize;\n        let empty = width - filled;\n        \n        let bar = \"â–ˆ\".repeat(filled) + &\"â–‘\".repeat(empty);\n        println!(\"Progress: [{}] {:.1}%\", bar, metrics.success_rate);\n    }\n\n    /// Clear screen\n    fn clear_screen(&self) {\n        print!(\"\\x1b[2J\\x1b[H\");\n    }\n\n    /// Show dashboard header\n    fn show_header(&self) {\n        println!(\"ðŸš€ Router Flood - Real-time Dashboard\");\n        println!(\"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n        println!(\"Starting monitoring...\");\n        println!();\n    }\n\n    /// Show final summary\n    fn show_final_summary(&self) {\n        println!();\n        println!(\"ðŸŽ¯ Final Summary\");\n        println!(\"â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\");\n        \n        let final_metrics = self.collector.get_metrics();\n        let uptime = self.start_time.elapsed();\n        \n        println!(\"Total Runtime:    {}\", format_duration(uptime));\n        println!(\"Packets Sent:     {}\", final_metrics.packets_sent);\n        println!(\"Packets Failed:   {}\", final_metrics.packets_failed);\n        println!(\"Success Rate:     {:.1}%\", final_metrics.success_rate);\n        println!(\"Average Rate:     {:.1} pps\", final_metrics.packets_per_second);\n        println!(\"Total Data:       {}\", format_bytes(final_metrics.bytes_sent));\n        println!(\"Average Bandwidth: {:.2} Mbps\", final_metrics.bandwidth_mbps);\n        println!();\n    }\n\n    /// Export dashboard state to JSON\n    pub async fn export_state(&self, filename: &str) -> Result<(), Box<dyn std::error::Error>> {\n        let state = self.get_dashboard_state().await;\n        let json = serde_json::to_string_pretty(&state)?;\n        tokio::fs::write(filename, json).await?;\n        Ok(())\n    }\n}\n\n/// Builder for dashboard configuration\npub struct DashboardBuilder {\n    config: DashboardConfig,\n}\n\nimpl DashboardBuilder {\n    pub fn new() -> Self {\n        Self {\n            config: DashboardConfig::default(),\n        }\n    }\n\n    pub fn update_interval(mut self, interval: Duration) -> Self {\n        self.config.update_interval = interval;\n        self\n    }\n\n    pub fn compact_mode(mut self, enabled: bool) -> Self {\n        self.config.compact_mode = enabled;\n        self\n    }\n\n    pub fn show_system_info(mut self, enabled: bool) -> Self {\n        self.config.show_system_info = enabled;\n        self\n    }\n\n    pub fn show_progress_bar(mut self, enabled: bool) -> Self {\n        self.config.show_progress_bar = enabled;\n        self\n    }\n\n    pub fn alert_thresholds(mut self, thresholds: AlertThresholds) -> Self {\n        self.config.alert_thresholds = thresholds;\n        self\n    }\n\n    pub fn build(self) -> DashboardConfig {\n        self.config\n    }\n}\n\nimpl Default for DashboardBuilder {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n"