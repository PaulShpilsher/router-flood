//! Threat detection and security hardening for Phase 5\n//!\n//! This module provides additional input validation and threat detection\n//! capabilities to enhance the security posture of the application.\n\nuse std::collections::HashMap;\nuse std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::{Arc, Mutex};\nuse std::time::{Duration, Instant};\nuse serde::{Deserialize, Serialize};\n\nuse crate::error::{Result, ValidationError};\n\n/// Threat detection system\npub struct ThreatDetector {\n    config: ThreatDetectionConfig,\n    rate_limiter: RateLimiter,\n    input_validator: InputValidator,\n    anomaly_detector: AnomalyDetector,\n    threat_log: Arc<Mutex<Vec<ThreatEvent>>>,\n}\n\n/// Threat detection configuration\n#[derive(Debug, Clone)]\npub struct ThreatDetectionConfig {\n    pub enable_rate_limiting: bool,\n    pub enable_input_validation: bool,\n    pub enable_anomaly_detection: bool,\n    pub max_requests_per_minute: u64,\n    pub max_packet_size: usize,\n    pub max_target_ports: usize,\n    pub suspicious_pattern_threshold: u64,\n}\n\n/// Rate limiter for preventing abuse\npub struct RateLimiter {\n    requests: Arc<AtomicU64>,\n    window_start: Arc<Mutex<Instant>>,\n    max_requests: u64,\n    window_duration: Duration,\n}\n\n/// Enhanced input validator\npub struct InputValidator {\n    config: ThreatDetectionConfig,\n}\n\n/// Anomaly detection system\npub struct AnomalyDetector {\n    baseline_metrics: Arc<Mutex<BaselineMetrics>>,\n    anomaly_threshold: f64,\n}\n\n/// Baseline metrics for anomaly detection\n#[derive(Debug, Clone)]\nstruct BaselineMetrics {\n    avg_packet_rate: f64,\n    avg_packet_size: f64,\n    common_ports: HashMap<u16, u64>,\n    last_update: Instant,\n}\n\n/// Threat event for logging\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ThreatEvent {\n    pub timestamp: String,\n    pub threat_type: ThreatType,\n    pub severity: ThreatSeverity,\n    pub description: String,\n    pub source_info: Option<String>,\n    pub mitigation_action: String,\n}\n\n/// Types of threats\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ThreatType {\n    RateLimitExceeded,\n    InvalidInput,\n    SuspiciousPattern,\n    AnomalousActivity,\n    PrivilegeEscalation,\n    ConfigurationTampering,\n}\n\n/// Threat severity levels\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ThreatSeverity {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n/// Validation result\n#[derive(Debug)]\npub struct ValidationResult {\n    pub is_valid: bool,\n    pub threats: Vec<ThreatEvent>,\n    pub sanitized_input: Option<String>,\n}\n\nimpl Default for ThreatDetectionConfig {\n    fn default() -> Self {\n        Self {\n            enable_rate_limiting: true,\n            enable_input_validation: true,\n            enable_anomaly_detection: true,\n            max_requests_per_minute: 100,\n            max_packet_size: 65535,\n            max_target_ports: 1000,\n            suspicious_pattern_threshold: 10,\n        }\n    }\n}\n\nimpl ThreatDetector {\n    /// Create a new threat detector\n    pub fn new(config: ThreatDetectionConfig) -> Self {\n        let rate_limiter = RateLimiter::new(\n            config.max_requests_per_minute,\n            Duration::from_secs(60),\n        );\n        \n        Self {\n            rate_limiter,\n            input_validator: InputValidator::new(config.clone()),\n            anomaly_detector: AnomalyDetector::new(),\n            threat_log: Arc::new(Mutex::new(Vec::new())),\n            config,\n        }\n    }\n\n    /// Validate and check for threats in configuration\n    pub fn validate_configuration(&self, config_data: &str) -> Result<ValidationResult> {\n        let mut threats = Vec::new();\n        let mut is_valid = true;\n\n        // Rate limiting check\n        if self.config.enable_rate_limiting {\n            if let Err(threat) = self.rate_limiter.check_rate_limit() {\n                threats.push(threat);\n                is_valid = false;\n            }\n        }\n\n        // Input validation\n        if self.config.enable_input_validation {\n            match self.input_validator.validate_config_input(config_data) {\n                Ok(validation_threats) => threats.extend(validation_threats),\n                Err(_) => {\n                    is_valid = false;\n                    threats.push(ThreatEvent {\n                        timestamp: chrono::Utc::now().to_rfc3339(),\n                        threat_type: ThreatType::InvalidInput,\n                        severity: ThreatSeverity::High,\n                        description: \"Configuration validation failed\".to_string(),\n                        source_info: None,\n                        mitigation_action: \"Configuration rejected\".to_string(),\n                    });\n                }\n            }\n        }\n\n        // Log threats\n        if !threats.is_empty() {\n            self.log_threats(&threats);\n        }\n\n        Ok(ValidationResult {\n            is_valid,\n            threats,\n            sanitized_input: if is_valid { Some(config_data.to_string()) } else { None },\n        })\n    }\n\n    /// Validate target IP address for security\n    pub fn validate_target_ip(&self, ip: &IpAddr) -> Result<()> {\n        // Check if IP is in private ranges (security requirement)\n        if !self.is_private_ip(ip) {\n            let threat = ThreatEvent {\n                timestamp: chrono::Utc::now().to_rfc3339(),\n                threat_type: ThreatType::InvalidInput,\n                severity: ThreatSeverity::Critical,\n                description: format!(\"Attempt to target public IP: {}\", ip),\n                source_info: Some(ip.to_string()),\n                mitigation_action: \"Request blocked\".to_string(),\n            };\n            \n            self.log_threats(&[threat]);\n            \n            return Err(ValidationError::InvalidIpRange {\n                ip: ip.to_string(),\n                reason: \"Only private IP addresses are allowed for security\",\n            }.into());\n        }\n\n        // Check for suspicious patterns\n        if self.is_suspicious_ip(ip) {\n            let threat = ThreatEvent {\n                timestamp: chrono::Utc::now().to_rfc3339(),\n                threat_type: ThreatType::SuspiciousPattern,\n                severity: ThreatSeverity::Medium,\n                description: format!(\"Suspicious IP pattern detected: {}\", ip),\n                source_info: Some(ip.to_string()),\n                mitigation_action: \"Request flagged for review\".to_string(),\n            };\n            \n            self.log_threats(&[threat]);\n        }\n\n        Ok(())\n    }\n\n    /// Validate port list for security\n    pub fn validate_ports(&self, ports: &[u16]) -> Result<()> {\n        // Check port count\n        if ports.len() > self.config.max_target_ports {\n            let threat = ThreatEvent {\n                timestamp: chrono::Utc::now().to_rfc3339(),\n                threat_type: ThreatType::SuspiciousPattern,\n                severity: ThreatSeverity::High,\n                description: format!(\"Excessive port count: {} (max: {})\", \n                    ports.len(), self.config.max_target_ports),\n                source_info: None,\n                mitigation_action: \"Request rejected\".to_string(),\n            };\n            \n            self.log_threats(&[threat]);\n            \n            return Err(ValidationError::ExceedsLimit {\n                field: \"target_ports\",\n                value: ports.len() as u64,\n                limit: self.config.max_target_ports as u64,\n            }.into());\n        }\n\n        // Check for suspicious port patterns\n        if self.has_suspicious_port_pattern(ports) {\n            let threat = ThreatEvent {\n                timestamp: chrono::Utc::now().to_rfc3339(),\n                threat_type: ThreatType::SuspiciousPattern,\n                severity: ThreatSeverity::Medium,\n                description: \"Suspicious port scanning pattern detected\".to_string(),\n                source_info: Some(format!(\"Ports: {:?}\", ports)),\n                mitigation_action: \"Request flagged for review\".to_string(),\n            };\n            \n            self.log_threats(&[threat]);\n        }\n\n        Ok(())\n    }\n\n    /// Check for anomalous activity\n    pub fn check_anomalies(&self, packet_rate: f64, packet_size: f64) -> Vec<ThreatEvent> {\n        if !self.config.enable_anomaly_detection {\n            return Vec::new();\n        }\n\n        self.anomaly_detector.detect_anomalies(packet_rate, packet_size)\n    }\n\n    /// Get threat summary\n    pub fn get_threat_summary(&self) -> ThreatSummary {\n        let threats = self.threat_log.lock().unwrap();\n        let total_threats = threats.len();\n        \n        let mut by_type = HashMap::new();\n        let mut by_severity = HashMap::new();\n        \n        for threat in threats.iter() {\n            *by_type.entry(format!(\"{:?}\", threat.threat_type)).or_insert(0) += 1;\n            *by_severity.entry(format!(\"{:?}\", threat.severity)).or_insert(0) += 1;\n        }\n        \n        ThreatSummary {\n            total_threats,\n            threats_by_type: by_type,\n            threats_by_severity: by_severity,\n            last_threat: threats.last().cloned(),\n        }\n    }\n\n    /// Log threats to the threat log\n    fn log_threats(&self, threats: &[ThreatEvent]) {\n        let mut log = self.threat_log.lock().unwrap();\n        for threat in threats {\n            log.push(threat.clone());\n            \n            // Log to system log as well\n            match threat.severity {\n                ThreatSeverity::Critical => {\n                    eprintln!(\"ðŸš¨ CRITICAL THREAT: {} - {}\", threat.threat_type_str(), threat.description);\n                }\n                ThreatSeverity::High => {\n                    eprintln!(\"âš ï¸ HIGH THREAT: {} - {}\", threat.threat_type_str(), threat.description);\n                }\n                ThreatSeverity::Medium => {\n                    eprintln!(\"âš ï¸ MEDIUM THREAT: {} - {}\", threat.threat_type_str(), threat.description);\n                }\n                ThreatSeverity::Low => {\n                    eprintln!(\"â„¹ï¸ LOW THREAT: {} - {}\", threat.threat_type_str(), threat.description);\n                }\n            }\n        }\n    }\n\n    /// Check if IP is in private ranges\n    fn is_private_ip(&self, ip: &IpAddr) -> bool {\n        match ip {\n            IpAddr::V4(ipv4) => {\n                ipv4.is_private() || ipv4.is_loopback() || ipv4.is_link_local()\n            }\n            IpAddr::V6(ipv6) => {\n                ipv6.is_loopback() || ipv6.is_unique_local() || ipv6.is_link_local()\n            }\n        }\n    }\n\n    /// Check for suspicious IP patterns\n    fn is_suspicious_ip(&self, ip: &IpAddr) -> bool {\n        match ip {\n            IpAddr::V4(ipv4) => {\n                let octets = ipv4.octets();\n                // Check for common suspicious patterns\n                octets[0] == 0 || // Invalid network\n                (octets[0] == 169 && octets[1] == 254) || // Link-local (suspicious in this context)\n                octets == [255, 255, 255, 255] // Broadcast\n            }\n            IpAddr::V6(_) => {\n                // For now, be conservative with IPv6\n                false\n            }\n        }\n    }\n\n    /// Check for suspicious port patterns\n    fn has_suspicious_port_pattern(&self, ports: &[u16]) -> bool {\n        // Check for sequential port scanning\n        if ports.len() > 10 {\n            let mut sequential_count = 0;\n            for window in ports.windows(2) {\n                if window[1] == window[0] + 1 {\n                    sequential_count += 1;\n                }\n            }\n            \n            // If more than 70% of ports are sequential, it's suspicious\n            if sequential_count as f64 / ports.len() as f64 > 0.7 {\n                return true;\n            }\n        }\n        \n        // Check for common attack patterns\n        let suspicious_ports = [21, 22, 23, 25, 53, 135, 139, 445, 1433, 3389];\n        let suspicious_count = ports.iter()\n            .filter(|&&port| suspicious_ports.contains(&port))\n            .count();\n        \n        // If targeting many commonly attacked ports, it's suspicious\n        suspicious_count > 5\n    }\n}\n\nimpl RateLimiter {\n    fn new(max_requests: u64, window_duration: Duration) -> Self {\n        Self {\n            requests: Arc::new(AtomicU64::new(0)),\n            window_start: Arc::new(Mutex::new(Instant::now())),\n            max_requests,\n            window_duration,\n        }\n    }\n\n    fn check_rate_limit(&self) -> Result<(), ThreatEvent> {\n        let now = Instant::now();\n        let mut window_start = self.window_start.lock().unwrap();\n        \n        // Reset window if expired\n        if now.duration_since(*window_start) >= self.window_duration {\n            *window_start = now;\n            self.requests.store(0, Ordering::Relaxed);\n        }\n        \n        let current_requests = self.requests.fetch_add(1, Ordering::Relaxed) + 1;\n        \n        if current_requests > self.max_requests {\n            Err(ThreatEvent {\n                timestamp: chrono::Utc::now().to_rfc3339(),\n                threat_type: ThreatType::RateLimitExceeded,\n                severity: ThreatSeverity::High,\n                description: format!(\"Rate limit exceeded: {} requests in window (max: {})\", \n                    current_requests, self.max_requests),\n                source_info: None,\n                mitigation_action: \"Request throttled\".to_string(),\n            })\n        } else {\n            Ok(())\n        }\n    }\n}\n\nimpl InputValidator {\n    fn new(config: ThreatDetectionConfig) -> Self {\n        Self { config }\n    }\n\n    fn validate_config_input(&self, input: &str) -> Result<Vec<ThreatEvent>> {\n        let mut threats = Vec::new();\n        \n        // Check for excessively large input\n        if input.len() > 1_000_000 { // 1MB limit\n            threats.push(ThreatEvent {\n                timestamp: chrono::Utc::now().to_rfc3339(),\n                threat_type: ThreatType::SuspiciousPattern,\n                severity: ThreatSeverity::High,\n                description: format!(\"Excessively large input: {} bytes\", input.len()),\n                source_info: None,\n                mitigation_action: \"Input truncated\".to_string(),\n            });\n        }\n        \n        // Check for suspicious patterns\n        let suspicious_patterns = [\n            \"../\", \"..\\\\\\\\", // Path traversal\n            \"<script\", \"javascript:\", // XSS attempts\n            \"DROP TABLE\", \"DELETE FROM\", // SQL injection\n            \"${{\", \"#{{\", // Template injection\n        ];\n        \n        for pattern in &suspicious_patterns {\n            if input.to_lowercase().contains(&pattern.to_lowercase()) {\n                threats.push(ThreatEvent {\n                    timestamp: chrono::Utc::now().to_rfc3339(),\n                    threat_type: ThreatType::SuspiciousPattern,\n                    severity: ThreatSeverity::Medium,\n                    description: format!(\"Suspicious pattern detected: {}\", pattern),\n                    source_info: None,\n                    mitigation_action: \"Input sanitized\".to_string(),\n                });\n            }\n        }\n        \n        Ok(threats)\n    }\n}\n\nimpl AnomalyDetector {\n    fn new() -> Self {\n        Self {\n            baseline_metrics: Arc::new(Mutex::new(BaselineMetrics {\n                avg_packet_rate: 100.0,\n                avg_packet_size: 1000.0,\n                common_ports: HashMap::new(),\n                last_update: Instant::now(),\n            })),\n            anomaly_threshold: 3.0, // 3 standard deviations\n        }\n    }\n\n    fn detect_anomalies(&self, packet_rate: f64, packet_size: f64) -> Vec<ThreatEvent> {\n        let mut threats = Vec::new();\n        let baseline = self.baseline_metrics.lock().unwrap();\n        \n        // Check packet rate anomaly\n        if packet_rate > baseline.avg_packet_rate * self.anomaly_threshold {\n            threats.push(ThreatEvent {\n                timestamp: chrono::Utc::now().to_rfc3339(),\n                threat_type: ThreatType::AnomalousActivity,\n                severity: ThreatSeverity::Medium,\n                description: format!(\"Anomalous packet rate: {:.1} (baseline: {:.1})\", \n                    packet_rate, baseline.avg_packet_rate),\n                source_info: None,\n                mitigation_action: \"Activity monitored\".to_string(),\n            });\n        }\n        \n        // Check packet size anomaly\n        if packet_size > baseline.avg_packet_size * self.anomaly_threshold {\n            threats.push(ThreatEvent {\n                timestamp: chrono::Utc::now().to_rfc3339(),\n                threat_type: ThreatType::AnomalousActivity,\n                severity: ThreatSeverity::Low,\n                description: format!(\"Anomalous packet size: {:.1} (baseline: {:.1})\", \n                    packet_size, baseline.avg_packet_size),\n                source_info: None,\n                mitigation_action: \"Activity monitored\".to_string(),\n            });\n        }\n        \n        threats\n    }\n}\n\nimpl ThreatEvent {\n    fn threat_type_str(&self) -> &'static str {\n        match self.threat_type {\n            ThreatType::RateLimitExceeded => \"RATE_LIMIT\",\n            ThreatType::InvalidInput => \"INVALID_INPUT\",\n            ThreatType::SuspiciousPattern => \"SUSPICIOUS_PATTERN\",\n            ThreatType::AnomalousActivity => \"ANOMALOUS_ACTIVITY\",\n            ThreatType::PrivilegeEscalation => \"PRIVILEGE_ESCALATION\",\n            ThreatType::ConfigurationTampering => \"CONFIG_TAMPERING\",\n        }\n    }\n}\n\n/// Threat summary for reporting\n#[derive(Debug, Serialize, Deserialize)]\npub struct ThreatSummary {\n    pub total_threats: usize,\n    pub threats_by_type: HashMap<String, u64>,\n    pub threats_by_severity: HashMap<String, u64>,\n    pub last_threat: Option<ThreatEvent>,\n}\n"